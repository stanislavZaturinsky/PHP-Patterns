<?php
//====================================================================================
//---- Инкапсуляция. Общее понятие. Понимание сокрытия свойств и методов, а также умение обосновать свои действия.
//====================================================================================

//Инкапсуляция — механизм языка программирования, ограничивающий доступ к составляющим
//объект компонентам (методам и свойствам), делает их приватными, то есть доступными только
//внутри объекта.
//Инкапсуляция – сокрытие реализации работы какого-либо объекта от пользователя с помощью
//спецификаторов доступа и невозможность воздействовать на объект никак иначе, как только через
//предоставляемый  интерфейс в виде строго определенных публичных методов.

//------------------------------- Принципы инкапсуляции
//Пользователь может взаимодействовать с объектом только через этот интерфейс. Реализуется с
//помощью ключевого слова: public.
//Пользователь не может использовать закрытые данные и методы. Реализуется с помощью
//ключевых слов: private, protected.
//Не рекомендуется давать доступ к переменным класса напрямую извне.
//Доступ к данным должен осуществляться через специальные методы доступа (access methods) –
//«геттеры» (методы получения данных, Get) и «сеттеры» (методы установки данных, Set).
//Метод-получатель (геттер) должен возвращать значение того же типа, что и само поле и не
//имеет параметров

//------------------------------- Пример
//Инкапсуляцию можно сравнить с работой автомобиля с точки зрения типичного водителя. Многие
//водители не разбираются в подробностях внутреннего устройства машины, но при этом управляют
//ею именно так, как было задумано. Пусть они не знают, как устроен двигатель, тормоз или рулевое
//управление, — существует специальный интерфейс, который автоматизирует и упрощает эти сложные
//операции. Сказанное также относится к инкапсуляции и ООП — многие подробности "внутреннего устройства"
//скрываются от пользователя, что позволяет ему сосредоточиться на решении конкретных задач. В ООП
//эта возможность обеспечивается классами, объектами и различными средствами выражения иерархических
//связей между ними.
//
//Другими словами,  вы даете пользователю некий класс и некий интерфейс. Пользователь может работать
//с объектом класса только через интерфейс, любые возможности влияния на объект кроме как через интерфейс
//должны быть исключены.

//Имеется класс у которого есть метод ,выводящий некую сводную информацию, в числе которой  -
//фамилия создателя. Доступ к исходникам пользователь не имеет (код обфусцирован). На данный момен это
//выглядит так:
//
//class MyClass{
//    public $nameCoder = 'Кущенков';
//
//    // некие другие методы и свойства
//
//    public function getFooter(){
//        return 'Владелец ' . $this->nameCoder;
//    }
//}

//Пользователь создал объект, воспользовался методом getFooter(), но ему не понравилась фамилия создателя
//и он захотел изменить ее на свою. В свойствах объекта он видит, что свойство $nameCoder публичное и меняет
//его напрямую: $obj->nameCoder = “Зильберман”. Таким образом, он вмешался в работу класса и изменил его
//логику так, как не было предусмотрено создателем класса.  Если же создатель класса сделал  бы свойство
//$nameCoder приватным, такой бы номер не проканал. На этом примере мы видим смысл инкапсуляции – не дать
//пользователю вмешиваться в работу класса.
//
//Помимо просто сокрытия определнных методов и свойств,  принцип инкапсуляции включает в себя невозможность
//обратиться к свойствам класса напрямую. Т.е. все переменные (свойства) класса вы делаете скрытыми (private),
//а доступ к этим свойствам реализовываете через методы. Т.е. можно будет взаимодействовать со свойствами
//класса через методы и никак иначе. В этом случае ни одно свойство не сможет быть переопределено случайно
//или умышленно. Прелесть получения доступа к свойствам через метод еще и в том, что в методах можно вставить
//код для проверки всяких ошибок, валидаций и т.д. и потом не думать о них, когда вызывается метод.

//Рассмотрим следующий пример, нарушающий принцип инкапсуляции
//class MailService
//{
//    private $subject;
//    public $message;
//    private $recipient;
//
//    public function setDatas($recipient, $subject, $message)
//    {
//        $this->recipient = $recipient;
//        $this->subject = $subject;
//        $this->message = $message;
//    }
//
//    public function send()
//    {
//        mail($this->recipient, $this->subject, $this->message);
//    }
//}
//
//
//class MailAttach extends MailService
//{
//    public $message = 'error attach';
//
//    public function attach($attach)
//    {
//        if(empty($attach))
//        {
//            echo $this->message;
//            die;
//        }
//    }
//}
//$obj = new MailAttach;
//$obj->setDatas('goper@tut.by', 'Тема', 'Cообщение');
//$obj->attach(null);
//$obj->send();

//В классе MailAttach мы тоже определили свойство $message, но оно служит для вывода текста ошибки.
//
//Т.к. у нас в метод attach() передается null, мы ожидаем увидеть сообщение 'error attach', но вместо
//этого увидим сообщение 'Cообщение', т.е. параметр, переданный в метод setDatas(), переопределяет
//общедоступное свойство $message.
//
//Теперь рассмотрим правильный код, где свойство $message будет в каждом классе приватным:
//class MailService
//{
//    private $subject;
//    private $message;
//    private $recipient;
//
//    public function setDatas($recipient, $subject, $message)
//    {
//        $this->recipient = $recipient;
//        $this->subject = $subject;
//        $this->message = $message;
//    }
//
//    public function send()
//    {
//        mail($this->recipient, $this->subject, $this->message);
//    }
//}
//
//
//class MailAttach extends MailService
//{
//    private $message = 'error attach';
//
//    public function attach($attach)
//    {
//        if(empty($attach))
//        {
//            echo $this->message;
//            die;
//        }
//    }
//}
//$obj = new MailAttach;
//$obj->setDatas('goper@tut.by', 'Тема', 'Сообщение');
//$obj->attach(null);
//$obj->send();

//В данном случае свойство $message в обоих классах обособлено длуг от друга. Если бы мы захотели
//его вызвать в классе MailAttach, у нас бы возникла ошибка доступа, но определяя его в классе-наследники
//заново, мы делаем его независимым от наследуемого класса и код отработает рвоно так, как нам нужно: в
//функцию mail() попадет 'Сообщение', а метод attach() вернет 'error attach'.
//
//Таким образом, вы можете быть уверены, что свойства двух классов никаким образом не соприкоснутся и не нарушат
//логику работы друг друга.
//
//Тоже смое касается и методов.
//Пример
//class A
//{
//    private function method()
//    {
//        return 'A';
//    }
//
//    public function t(){
//        return $this->method();
//    }
//}
//
//class B extends A
//{
//    public function method()
//    {
//        return 'B';
//    }
//}
//$obj = new B;
//echo $obj->method();
//echo $obj->t();
// выведет BA

//Этот пример показывает, что если мы случайно в классе-наследнике создали метод с таким же именем, как
//и в наследуемом классе, то метод класса A будучи приватным (скрытым) никак не повлияет на одноименный
//метод класса B. Важно понимать, что method() класса B НЕ перекрывает method() класса A, а просто
//"не видит" его.

//====================================================================================
//---- Наследование. Общее понятие. Умение правильно определять наследуемый функционал для дочерних объектов,
//     умение избавляться от дублирования кода
//====================================================================================

//Наследование (inheritance) - это процесс, посредством которого один объект может приобретать
//свойства другого. Точнее, объект может наследовать основные свойства другого объекта и добавлять
//к ним черты, характерные только для него. Наследование является важным, поскольку оно позволяет
//поддерживать концепцию иерархии классов (hierarchical classification). Применение иерархии классов
//делает управляемыми большие потоки информации. Например, подумайте об описании жилого дома.
//Дом - это часть общего класса, называемого строением. С другой стороны, строение - это часть более
//общего класса - конструкции, который является частью ещё более общего класса объектов, который можно
//назвать созданием рук человека. В каждом случае порождённый класс наследует все, связанные с родителем,
//качества и добавляет к ним свои собственные определяющие характеристики. Без использования иерархии
//классов, для каждого объекта пришлось бы задать все характеристики, которые бы исчерпывающи его
//определяли. Однако при использовании наследования можно описать объект путём определения того общего
//класса (или классов), к которому он относится, с теми специальными чертами, которые делают объект
//уникальным. Наследование играет очень важную роль в OOP.

//Часто необходимо создание классов содержащих переменные и функция аналогичные переменным и функциям
//из другого уже существующего класса. Является хорошей практикой определение общего класса, который
//может быть использован во всех проектах и адаптировать этот класс для нужд каждого конкретного проекта.
//Для облегчения этого, классы могут быть расширениями (производными) других классов.
//Производный класс имеет все переменные и функции базового класса (это называется "наследование") и,
//кроме того, все что вы добавляете в расширенном определении. Производные классы иногда называют
//классами-наследниками.
//Производный класс всегда зависит от одного базового класса, то есть множественное наследование не
//поддерживается.

//------------------------------- Пример
//объектно-ориентированные языки позволяют создавать модели, очень близкие к реальному миру. Для
//примера студентов и аспирантов мы можем сказать, что аспирант – это не простой студент. Он обладает
//дополнительными свойствами, но одновременно он обладает и всеми свойствами студента. Поэтому мы можем
//унаследовать класс GraduateStudent (аспирант) от класса Student (студент) с помощью ключевого слова extends.

//Наследование еще позволяет нам избавиться от повторения кода, потому что все открытые (public, protected)
//методы и свойства класса Student становятся доступными и в классе GraduateStudent. Если у нас есть
//свойство (или метод) private в классе Student, то оно не будет доступно в классе GraduateStudent:

//class Student {
// private $mark;
// protected $average;
//}
//
//class GraduateStudent extends Student {
//   function someFn() {
//     $this->mark = 5;      // Ошибка доступа!
//     $this->average = 4.4; // А так правильно
//   }
//}

//Кстати. Помните, что если свойство или метод в классе не имеют модификатора доступа, то по умолчанию
//они public? Видимо это было введено для совместимости с предыдущими версиями пхп, где модификаторов
//еще не было, а все члены класса были публичными. Вспомним еще конструкторы и деструкторы. Так вот, если
//нам надо вызвать конструктор или деструктор базового класса, то надо это делать явно, через указатель parent:

//class MyClass {
//    function __construct() {
//        echo "Запущен конструктор базового класса";
//    }
//
//    function __destruct() {
//        echo "Запущен деструктор базового класса";
//    }
//}
//
//class MyClass1 extends MyClass {
//    function __construct() {
//        parent::__construct();
//    }
//
//    function __destruct() {
//        parent::__destruct();
//    }
//}
//$obj = new MyClass1(); // Выводит "Запущен конструктор базового класса"
//unset($obj);           // Выводит "Запущен деструктор базового класса"

//------------------------------- Финальные методы и классы
//Интересная возможность в пхп 5, на которую я наткнулся в ходе изучения ООП, – это возможность
//определять финальные методы и классы. Метод, который мы определили с ключевым словом final, в дальнейшем
//мы не можем переопределить в классах, которые производны от нашего класса:

//class MyClass {
//    final public function fn() {
//        // Код метода
//    }
//}
//
//class MyClass1 extends MyClass {
//    // Следующий код вызывает ошибку переопределения финального метода
//    // базового класса MyClass
//    public function fn() {
//        // Код метода
//    }
//}

//Тут заметим, что если класс определен как final, то и все методы этого класса автоматически станут
//финальными, и определять их явно как final уже не надо. А как насчет свойств? Свойства класса определять
//финальными нельзя. Ну в этом не было бы смысла, думаю. Потому что, в отличие от методов, мы не можем
//переопределять свойства класса. Мы можем их только наследовать.

//Модификатор protected с точки зрения вызывающей программы выглядит точно так же, как и private: он
//запрещает доступ к данным объекта извне. Однако в отличие от private он позволяет обращаться к данным не
//только из методов своего класса, но также и из методов подкласса.

