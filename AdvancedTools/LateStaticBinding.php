<?php
//abstract class DomainObject {
//}
//
//class User extends DomainObject {
//    public static function create() {
//        return new User();
//    }
//}
//
//class Document extends DomainObject {
//    public static function create() {
//        return new Document();
//    }
//}
////Сначала я создал суперкласс под именем DomainObject. Само собой разумеется,
////что в реальном проекте в нем будет находиться функциональность, общая для всех
////дочерних классов. После этого я создал два дочерних класса: User и Document. Я хотел,
////чтобы в каждом из моих конкретных классов находился метод create().
//
////Созданный мною выше код прекрасно работает, но в нем есть досадный недостаток
////- дублирование. Мне совсем не нравится повторять однотипный код наподобие
////того, который приведен выше. для каждого создаваемого дочернего объекта,
////расширяющего класс DomainObject. Как насчет того, чтобы переместить метод
////create() в суперкласс?
//
//abstract class DomainObject {
//    public static function create() {
//        return new self();
//    }
//}
//
//class User extends DomainObject {
//}
//
//class Document extends DomainObject {
//}
//
//Document::create();
////Ну что ж, все это выглядит круто! Теперь весь общий код сосредоточен в одном
////месте, и, чтобы обратиться к текущему классу, я воспользовался ключевым словом
////self. Однако насчет ключевого слова self я сделал допущение, что оно должн.о так
////работать. На самом деле оно не работает для классов так же, как псевдопеременная
////$this для объектов. С помощью ключевого слова self нельзя сослаться на вызывающий
////контекст. Оно используется только для разрешения ссылок на содержащий
////класс, в контексте которого вызывается метод. Поэтому при попытке запуска приведенного
////выше примера получим следующее сообщение об ошибке.
////РНР Fatal error:Cannot instantiate abstract class DomainObject in ..
//
////Таким образом. ключевое слово self трансформируется в ссылку на класс
////DomainObject, в котором определен метод create(), а не на класс Document, для которого
////этот метод должен быть вызван. До появления РНР 5.3 это было серьезным
////ограничением языка, которое породило массу неуклюжих обходных решений. В
////РНР 5.3 впервые введена концепция позднего статического связывания (late static
////bindings). Самым заметным ее проявлением является введение нового (в данном
////контексте) ключевого слова static. Оно аналогично ключевому слову self, за исключением
////того, что относится к вызывающему, а не содержащему классу. В данном
////случае это означает, что в результате вызова метода Document::create() возвращается
////новый объект типа Document и не будет предприниматься безуспешная
////попытка создать объект типа DomainObject.
////Итак, теперь я смогу воспользоваться всеми преимуществами наследования в
////статическом контексте.
//abstract class DomainObject {
//    public static function create() {
//        return new static();
//    }
//}
//
//class User extends DomainObject {
//}
//
//class Document extends DomainObject {
//}
//
//print_r(Document::create());
////---------------------------------------------- RESULT
////Document Object
////{
////}
//
////Ключевое слово static можно использовать не только для создания объектов.
////Так же, как и self и parent, его можно использовать как идентификатор для вызова
////статических методов даже из нестатического контекста. Например, я хочу реализовать
////идею группировки моих классов типа DomainObject. По умолчанию все классы
////попадают в категорию 'default'. Но для некоторых веток иерархии наследования
////моих классов мне нужно это переопределить.
abstract class DomainObject {
    private $group;

    public function __construct() {
        $this->group= static::create();
    }

    public static function create() {
        return new static();
    }

    static function getGroup() {
        return "default";
    }
}

class User extends DomainObject {
}

class Document extends DomainObject {
    static function getGroup() {
        return "document";
    }
}

class SpreadSheet extends Document {
}

print_r(User::create());
print_r(SpreadSheet::create());
//Здесь в класс DomainObject я ввел конструктор, в котором используется ключевое
//слово static для вызова метода getGroup(}. Стандартное значение группы сосредоточено
//в классе DomainObject, но оно переопределяется в классе Document. Я также
//создал новый класс SpreadSheet, расширяющий класс Document. Вот что получим в
//результате.
//---------------------------------------------- RESULT
//User Object
//(
//[group:DomainObject:private] => default
//)
//SpreadSheet Object
//(
//[group:DomainObject:private] => document
//)
//Все происходящее с классом User не настолько очевидно и поэтому требует объяснений.
//В конструкторе класса DomainObject вызывается метод getGroup(), который
//интерпретатор находит в текущем классе. Несмотря на это. в случае с классом
//SpreadSheet поиск метода getGroup() начинается не с класса DomainObject. а с
//класса SpreadSheet, для которого из метода create() был вызван стандартный конструктор.
//Поскольку в классе SpreadSheet реализация метода getGroup() не предусмотрена,
//интерпретатор вызывает аналогичный метод класса Document (т.е. идет
//вверх по иерархии объектов). До появления РНР 5.3 и позднего статического связывания
//здесь у меня возникала проблема из-за использования ключевого слова self,
//которое находило метод getGroup() только в классе DomainObject.