<?php
//Иногда все идет не так. как надо. Файлы где-то потерялись, объекты для связи
//с серверами баз данных остались не инициализированными. URL-aдpeca изменились,
//ХМL-файлы были повреждены. права доступа установлены неправильно. лимиты
//на дисковую память превышены. Этот список можно продолжать до бесконечности.
//В стремлении предусмотреть любую проблему простой метод может иногда
//утонуть под тяжестью собственного кода обработки ошибок.
//Ниже приведено определение простого класса Conf, который сохраняет. извлекает
//и определяет данные в ХМL-файле конфигурации.
class Conf {
    private $file;
    private $xml;
    private $lastmatch;

    function __construct($file) {
        $this->file = $file;
        $this->xml = simplexml_load_file($file);
    }

    function write() {
        file_put_contents($this->file, $this->xml->asXML());
    }

    function get($str) {
        $matches = $this->xml->xpath("/conf/item[@name=\"$str\"]");
        if(count($matches)) {
            $this->lastmatch = $matches[0];
            return (string)$matches[0];
        }
        return null;
    }

    function set($key, $value) {
        if(!is_null($this->get($key))) {
            $this->lastmatch[0] = $value;
            return;
        }
        $conf = $this->xml->conf;
        $this->xml->addChild('item', $value)->addAttribute('name', $key);
    }
}
//В классе Conf для доступа к парам "имя-значение" используется расширение
//РНР SimpleXml. Ниже приведен фрагмент файла конфигурации в формате ХМL,
//с которым работает наш класс.
//<?xml version="l.0" ?><?
//<conf>
// <item name="user">bob</item>
// <item name="pass">newpass</item>
// <item name="host">localhost</item>
//</conf>

//Конструктору класса Conf передается имя файла конфигурации, которое далее
//передается функции simplexml_load_file(). Полученный от функции объект
//типа SimpleXmlElement сохраняется в свойстве $xml. В методе get() для нахождения
//элемента item с заданным атрибутом name используется метод xpath объекта
//SimpleXmlElement. Значение найденного элемента возвращается в вызывающий
//код. Метод set() либо меняет значение существующего элемента, либо создает новый.
//И наконец метод write() сохраняет данные о новой конфигурации в исходном
//файле на диске.
//Как и многие коды. приведенные в качестве примеров, код класса Conf крайне
//упрощен. В частности, в нем не предусмотрена обработка ситуаций  когда файл
//конфигурации не существует или в него нельзя записать данные.
//Этот код также слишком "оптимистичен". В нем предполагается, что ХМL-документ правильно отформатирован
//и содержит ожидаемые элементы.
//Провести тестирование подобных ошибок достаточно просто , но мы должны решить,
//как нужно на них реагировать, если они возникнут. В целом у нас есть две
//возможности.
//l. Мы можем завершить выполнение программы. Это простой, но радикальный
//  выход. В результате наш скромный класс будет виноват в том, что из-за него
//  потерпела неудачу вся программа. Хотя такие методы. как _construct()
//  и write(), удачно расположены в коде для обнаружения ошибок, у них нет
//  информации, позволяющей решить, как обрабатывать эти ошибки.
//2. Вместо обработки ошибки в классе мы можем вернуть признак ошибки в том
//  или ином виде. Это может быть булево или целое значение, например о или
//  -1. В некоторых классах можно также сформировать текстовое сообщение
//  об ошибке или набор специальных признаков, чтобы клиентский код мог
//  запросить больше информации в случае неудачного завершения программы.

//Во многих РЕАR-пакетах сочетаются эти два подхода и возвращается объект
//ошибок (экземпляр класса PEAR Error). Наличие этого объекта говорит о том. что
//произошла ошибка, а подробнаЯ информация о ней содержится в самом объекте.
//Этот подход в настоящее время не рекомендуется использовать, но многие классы
//до сих пор не были обновлены в значительной степени из-за того, что клиентский
//код зачастую рассчитан на старые стандарты.
//Проблема также заключается еще и в том. что возвращаемое значение может
//быть затерто. В РНР нет средств, заставляющих возвращать унифицированное
//значение. На момент написания данной книги в РНР не поддерживались уточнения
//типа для возвращаемого класса, поэтому ничто не может нам помешать вернуть
//признак ошибки вместо ожидаемого объекта или значения элементарного типа.
//Делая так, мы должны полагаться на то, что клиентский код будет проверять тип
//возвращаемого объекта после каждого вызова нашего метода, подверженного
//ошибкам. А это довольно рискованно. Никому нельзя доверять!
//Когда в вызывающий код возвращается ошибочное значение, нет никакой
//гарантии, что клиентский код будет "вооружен" лучше нашего метода и сможет
//решить, как обрабатывать ошибку. А если не сможет, то проблемы будут появляться
//снова и снова. В клиентском методе нужно будет определить, как реагировать на
//ошибочную ситуацию, и, возможно, даже реализовать другую стратегию сообщения
//об ошибке.