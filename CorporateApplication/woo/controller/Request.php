<?php
namespace woo\controller;

class Request {
    private $properties;
    private $feedback = [];

    function __construct() {
        $this->init();
    }

    function init() {
        if(isset($_SERVER['REQUEST_METHOD'])) {
            $this->properties = $_REQUEST;
            return;
        }

        foreach($_SERVER['argv'] as $arg) {
            if(strpos($arg, '=')) {
                list($key, $val) = explode('=', $arg);
                $this->setProperty($key, $val);
            }
        }
    }

    function getProperty($key) {
        if(isset($this->properties[$key])) {
            return $this->properties[$key];
        }
        return null;
    }

    function setProperty($key, $val) {
        $this->properties[$key] = $val;
    }

    function addFeedback($msg) {
        array_push($this->feedback, $msg);
    }

    function getFeedback() {
        return $this->feedback;
    }

    function getFeedbackString($separator = '\n') {
        return implode($separator, $this->feedback);
    }
}
//-------------------------------- DOCUMENTATION
//Запросы магическим образом обрабатываются средствами РНР, и их параметры
//аккуратно складываются в суперглобальные массивы. Наверное, вы заметили, что
//мы для представления запроса до сих пор использовали класс. Объект Request передается
//CommandResolver, а затем - Command.
//Почему мы не позволяем этим классам напрямую обращаться к элементам массивов
//$_REQUEST, $_POST или $_GET? Конечно, мы МОГЛИ бы это сделать, но, централизуя
//операции запросов в одном месте, мы открываем для себя новые возможности.
//Например, можно применить фильтры к входящим запросам. Или, как показано в
//следующем примере, можно получить параметры не из НТТР-запроса, что позволит
//приложению запускаться из командной строки или из тестового сценария. Конечно,
//если в приложении используются сеансы, то вам придется предоставить альтернативный
//механизм сохранения, чтобы его можно было использовать в контексте командной
//строки. Тут вам пригодится шаблон Registry, который позволит генерировать
//различные классы Registry в соответствии с контекстом приложения.
//Объект Request - это также полезное хранилище для данных, которые нужно
//передать уровню представления. В этом отношении объект Request может также
//использоваться для генерации ответа.

//Как видите, большую часть этого класса занимают механизмы установки и получения
//свойств. Метод init() отвечает за наполнение закрытого массива $properties.
//Обратите внимание на то, что он работает с аргументами командной строки. так
//же как и с параметрами НТТР-запроса. Это чрезвычайно полезно, когда речь идет о
//тестировании и отладке.
//Как только будет получен объект Request, у вас должна быть возможность обратиться
//к параметру НТТР-запроса с помощью метода getProperty(). которому
//передается строка ключа, а он возвращает соответствующее значение (сохраненное
//в массиве $properties). Вы можете также добавить данные с помощью метода
//setProperty().
//Этот класс также управляет массивом $feedback. Это простой канал связи, через
//который классы-контроллеры могут передавать сообщения пользователю.