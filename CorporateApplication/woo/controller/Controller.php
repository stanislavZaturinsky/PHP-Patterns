<?php
namespace woo\controller;

class Controller {
    private $applicationHelper;

    private function __construct(){}

    static function run() {
        $instance = new Controller();
        $instance->init();
        $instance->handleRequest();
    }

    function init() {
        $applicationHelper = ApplicationHelper::instance();
        $applicationHelper->init();
    }

    function handleRequest() {
        $request = \woo\base\ApplicationRegistry::getRequest();
        $cmd_r   = new woo\command\CommandResolver();
        $cmd     = $cmd_r->getCommand($request);
        $cmd->execute($request);
    }
}

class ApplicationHelper {
    private static $instance = null;
    private $config = "data/woo_options.xml";

    private function __construct() {}

    static function instance() {
        if(is_null(self::$instance)) {
            self::$instance = new self();
        }
        return self::$instance;
    }

    function init() {
        $dsn = \woo\base\ApplicationRegistry::getDSN();
        if(!is_null($dsn)) {
            return;
        }
        $this->getOptions();
    }

    private function getOptions() {
        $this->ensure(file_exists($this->config), "Файл конфигурации не найден");
        $options = simplexml_load_file($this->config);
        $dsn = (string)$options->dsn;
        $this->ensure($dsn, "DSN е найден");
        \woo\base\ApplicationRegistry::setDSN($dsn);
        //Установите другие значения
    }

    private function ensure($expr, $message) {
        if(!$expr) {
            throw new \woo\base\AppException($message);
        }
    }
}
//-------------------------------- DOCUMENTATION
//Проблема
//Когда запросы обрабатываются в нескольких точках системы, очень трудно избежать
//дублирования в коде. Возможно, вам нужно аутентифицировать пользователя,
//перевести элементы интерфейса на другие языки или просто получить доступ
//к общим данным. Если для запроса требуется выполнять общие действия от одного
//представления к другому. то вы будете заниматься копированием и вставкой кода.
//Это усложнит внесение изменений, поскольку самое простое исправление нужно
//будет повторить в нескольких местах приложения . Поэтому может случиться так.
//что одни части кода перестанут соответствовать другим. Конечно, можно централизовать
//общие операции. выделив их в библиотечный код. но все равно останутся
//вызовы библиотечных функций или методов, разбросанные по всему приложению.
//Трудность в управлении продвижением от одного представления к другому - это
//еще одна проблема, которая может возникнуть в системе, где управление распределено
//между представлениями. В сложной системе подача запроса в одном представлении
//может привести к любому количеству страниц результатов в соответствии с
//входными данными и успешностью выполнения требуемых операций на уровне логики
//приложения. Логика перемещения от одного представления к другому может
//стать запутанной. особенно если одно и то же представление используется в различных
//потоках.

//Реализация
//Несмотря на то что класс Controller очень простой и в нем опущена обработка
//ошибок. больше в этом классе не должно быть ничего. Контроллер находится
//на верхушке системы, делегируя полномочия другим классам. Именно эти другие
//классы выполняют большую часть работы.
//Статический метод run() введен для удобства; в нем вызываются методы init()
//и handleRequest(). Поскольку конструктор нашего класса закрытый, для клиентского
//кода существует только единственная возможность начать выполнение нашей
//системы - вызвать метод run(). Обычно я делаю это в файле index.php, который
//содержит только пару строк кода.
//require ("woo/controller/Controller.php");
//\woo\controller\Controller::run();

//На самом деле разница между методами init() и handleRequest() почти неуловима
//в РНР. В некоторых языках метод init() будет выполняться только при запуске
//приложения, а метод handleRequest() или его эквивалент - при каждом запросе
//пользователя. В нашем же классе мы придерживаемся такого же различия между
//инициализацией и обработкой запросов, хотя метод init() вызывается для каждого
//запроса.

//Метод init() получает экземпляр класса под названием ApplicationHelper. В
//этом классе хранятся данные конфигурации для всего приложения. Метод init()
//нашего класса вызывает метод в классе ApplicationHelper, который также называется
//init(). В нем, как вы увидите позже, инициализируются данные, используемые
//приложением.
//В методе handleRequest() используется класс CommandResolver, чтобы получить
//объект типа Command, который он запускает, вызывая метод Command::execute().

//Класс ApplicationНelper
//Этот класс просто читает файл конфигурации и делает значения доступными
//для клиентского кода. Как видите, это еще один синглтон, с помощью которого
//конфигурационные данные легко можно сделать доступными для любого класса в
//системе. Существует альтернативный вариант: сделать класс ApplicationHelper
//стандартным и гарантировать, что он передается всем заинтересованным в нем
//объектам.
//Тот факт, что в классе ApplicationHelper мы используем ApplicationRegistry.
//предполагает выполнение рефакторинга кода. Возможно, стоит сделать сам класс
//ApplicationHelper системным реестром, вместо того чтобы создавать в системе два
//синглтона с частично совпадающими обязанностями. Для этого, возможно, придется
//задействовать рефакторинг кода, который был описан в предыдущем разделе (отделение
//основных функций класса ApplicationRegistry от сохранения и извлечения
//объектов. специфичных для конкретного приложения).

//Итак. метод init() отвечает за загрузку данных конфигурации. Фактически он
//проверяет ApplicationRegistry, чтобы узнать, сохранены ли данные в кеш-памяти.
//Если в объект Registry уже загружены данные, то метод init() вообще ничего не
//делает. Это очень полезно для приложений, в которых выполняется много очень
//ресурсоемких инициализаций. Сложная настройка может быть приемлемой в тех
//языках. в которых отделяется инициализация приложения от обработки отдельных
//запросов. В РНР вам нужно минимизировать процесс инициализации.
//Кеширование - очень эффективный метод. гарантирующий, что сложные и занимающие
//много времени процессы инициализации будут выполнены только при
//начальном запросе (вероятно, всего один раз), а все последующие запросы воспользуются
//хранимыми в памяти готовыми данными. Разумеется. в этом случае кеширование
//дает нам только небольшой выигрыш. Чуть ниже в этой главе будет показано.
//где именно наступает реальный выигрыш.
//Если это действит.елыю первый запуск приложения (или если кеш-память была
//очищена, - грубый, но эффективный способ заставить снова прочитать данные
//конфигурации) , то вызывается метод getOptions().
//В реальном приложении. вероятно. нужно будет выполнить намного больше работы.
//чем показано в данном примере. В нашей же версии все заканчивается получением
//значения параметра DSN. В методе getOptions() сначала проверяется,
//существует ли файл конфигурации (путь к нему сохраняется в свойстве $config).
//Затем он пытается загрузить ХМL-данные из файла и определить значение параметра
//DSN.

//Обратите внимание на то, что в классе ApplicationHelper используется особый
//прием для генерирования исключений. Вместо того чтобы "усеивать" код условными
//операторами и операторами throw наподобие
//if(!file_exists($this->config)) (
//  throw new \woo\base\AppException("Фaйл конфигурации не найден"); }

//в этом классе в методе под названием ensure() централизованы проверка условия
//и вызов оператора throw. Вы можете убедиться. что условие выполняется. или
//же в противном случае выдать исключение с помощью единственного (хотя и разбитого
//на две строки} оператора.
//$this->ensure(file_exists($this->config), "Файл конфигурации не найден");

//Подход с использованием кеш-памяти, выбранный здесь. дает нам два преимущества.
//Система может поддерживать простой в использовании файл конфигурации
//в формате ХМL. а кеширование означает, что к его значениям можно получать
//доступ почти без задержки. Конечно. если ваши конечные пользователи - тоже
//программисты или если вы не собираетесь слишком часто менять конфигурацию,
//можете включить определение структур данных РНР непосредственно во вспомогательный
//класс (или в отдельный файл. который включается в проект). И хотя это рискованный
//подход. он самый быстрый. Для получения данных конфигурации. представленных
//в виде пар "имя-значение", можно также использовать функцию РНР
//parse_ini_f1le(). Поскольку этот метод работает быстрее, чем синтаксический
//анализ ХМL-файла, именно его я использую в качестве основного для доступа к параметрам
//конфигурации в моих приложениях. Однако в классе ApplicationHelper
//ниже в этой главе мы будем использовать намного более сложные наборы данных.