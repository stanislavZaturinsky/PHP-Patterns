<?php
interface Chargeable {
    public function getPrice();
}

class ShopProduct implements Chargeable {
    //...
    public function getPrice() {
        return ($this->price - $this->discount);
    }
}
//------------------------------------------ DOCUMENTATION
//Как известно, в абстрактном классе допускается реализация некоторых методов,
//не объявленных абстрактными. В отличие от них, интерфейсы - это чистой воды
//шаблоны. С помощью интерфейса можно только определить функциональность,
//но не реализовать ее. Для объявления интерфейса используется ключевое слово
//interface. В интерфейсе могут находиться только объявления методов, но не тела
//этих методов.

//Как видите, интерфейс очень похож на класс. В любом классе, поддерживающем
//этот интерфейс, нужно реализовать все методы. определенные в интерфейсе; в противном
//случае класс должен быть объявлен как абстрактный.
//При реализации интерфейса в классе имя интерфейса указывается в объявлении
//этого класса после ключевого слова implements. После этого процесс реализации
//интерфейса станет точно таким же, как расширение абстрактного класса, который
//содержит только абстрактные методы.

//В классе ShopProduct уже есть метод getPrice(), что же может быть полезного в
//реализации интерфейса Chargeable? И снова ответ связан с типами. Дело в том, что
//реализующий класс принимает тип класса и интерфейса, который он расширяет.
//Это означает, что класс CDProduct относится к следующим типам.
//CDProduct
//ShopProduct
//ChargeaЫe

//Эту особенность можно использовать в клиентском коде. Как известно, тип
//объекта определяет его функциональные возможности. Поэтому метод
//public function CDinfo ( CDProduct $prod ) {
//    //..

//знает, что у объекта $prod есть метод getPlayLength(), а также все остальные методы,
//определенные в классе ShopProduct и интерфейсе Chargeable.
//Если тот же самый объект CDProduct передается методу
//public function addProduct ( ShopProduct $prod ) {
//    //...

//то известно, что объект $prod поддерживает все методы, определенные в классе
//ShopProduct. Однако без дальнейшей проверки данный метод ничего не будет знать
//о методе getPlayLength().
//И снова, если передать тот же объект CDProduct методу
//public function addChargeableItem ( Chargeable $item ) {
//    //...

//данному методу ничего не будет известно обо всех методах, определенных в классах
//ShopProduct или CDProduct. При этом интерпретатор только проверит, содержится
//ли в аргументе $item метод getPrice().

//Поскольку интерфейс можно реализовать в любом классе (на самом деле в классе
//можно реализовать любое количество интерфейсов), с помощью интерфейсов можно
//эффективно объединить типы данных, не связанных никакими другими отношениями.
//В результате мы можем определить совершенно новый класс, в котором
//реализуется интерфейс Chargeable.

//class Shipping implements Chargeable
//public function getPrice() {
//    //..

//Затем объект типа Shipping мы можем передать методу addChargeableItem(),
//точно так же. как мы передавали ему объект типа ShopProduct.
//Для клиента, работающего с объектом типа ChargeaЬle, очень важно то, что он
//может вызвать метод getPrice(). Любые другие имеющиеся методы связаны с другими
//типами - через собственный класс объекта, суперкласс или другой интерфейс.
//Но они не имеют никакого отношения к нашему клиенту.
//В классе можно как расширить суперкласс, так и реализовать любое количество
//интерфейсов. При этом ключевое слово extend s должно предшествовать ключевому
//слову implements. как показано ниже.

//class Consultancy extends TimedService implements Вооkаblе, Chargeable {
//    //..

//Обратите внимание на то, что в классе Consultancy реализуется более одного интерфейса.
//После ключевого слова implement s можно перечислить через запятую несколько
//интерфейсов.
//В РНР поддерживается только наследование от одного родителя (так называемое
//одиночное наследование), поэтому после ключевого слова extends можно указать
//только одно имя базового класса.