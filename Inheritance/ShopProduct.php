<?php
class ShopProduct {
    public $numPages;
    public $playLength;
    public $title;
    public $producerMainName;
    public $producerFirstName;
    public $price;

    function __construct($title, $firstName,
                         $mainName, $price,
                         $numPages = 0, $playLength = 0) {
        $this->title             = $title;
        $this->producerFirstName = $firstName;
        $this->producerMainName  = $mainName;
        $this->price             = $price;
        $this->numPages          = $numPages;
        $this->playLength        = $playLength;
    }

    function getProducer() {
        $base  = "$this->title ({$this->producerMainName},";
        $base .= "{$this->producerFirstName})";
        return $base;
    }

    function getSummaryLine() {
        $base  = "$this->title ({$this->producerMainName},";
        $base .= "{$this->producerFirstName} )";
        return $base;
    }
}

class CDProduct extends ShopProduct {
    public $playLength;

    function __construct($title, $firstName,
                         $mainName, $price, $playLength = 0) {
        parent::construct($title, $firstName, $mainName, $price);
        $this->playLength = $playLength;
    }

    function getPlayLength() {
        return $this->playLength;
    }

    function getSummaryLine() {
        $base  = parent::getSummaryLine();
        $base .= ": Время звучания - {$this->playLength}";
        return $base;
    }
}

class BookProduct extends ShopProduct {
    public $numPages;

    function __construct($title, $firstName,
                         $mainName, $price, $numPages = 0) {
        parent::construct($title, $firstName, $mainName, $price);
        $this->numPages = $numPages;
    }

    function getNumberOfPages() {
        return $this->numPages;
    }

    function getSummaryLine() {
        $base  = "$this->title ({$this->producerMainName},";
        $base .= "{$this->producerFirstName} )";
        $base .= ": {$this->numPages} стр.";
        return $base;
    }
}
//------------------------------------------ DOCUMENTATION
//Первый шаг в построении дерева наследования - найти элементы базового
//класса, которые не соответствуют друг другу или которыми нужно оперировать
//иначе.
//Мы знаем, что методы getPlayLength() и getNumЬerOfPages() противоречат один
//другому. Нам также известно, что нужно создать разные реализации метода get
//SummaryLine(). Давайте используем эти различия как основу для создания двух производных
//классов.

//Чтобы создать дочерний класс, необходимо использовать в объявлении класса
//ключевое слово extends. В данном примере мы создали два новых класса, BookProduct
//и CDProduct. Оба они расширяют класс ShopProduct.
//Поскольку в производных классах конструкторы не определяются. при создании
//экземпляров объектов этих классов будет автоматически вызываться конструктор
//родительского класса. Дочерние классы наследуют доступ ко всем методам типа
//public и protected родительского класса (но не к методам и свойствам типа private).
//Это означает, что мы можем вызвать метод getProducer() для экземпляра объекта
//класса CDProduct, хотя метод getProducer() определен в классе ShopProduct.

//$product2 = new CDProduct ("Пропавший без вести",
//    "Группа", "ДДТ",
//    10.99, null, 60.33) ;
//print "Исполнитель : { $product2- >getProducer())\n";

//Таким образом, оба наших дочерних класса наследуют поведение общего родительского
//класса. И мы можем обращаться с объектом BookProduct так. как будто
//это объект типа ShopProduct. Мы можем передать объект BookProduct или CDProduct
//методу write() класса ShopProductWriter, и все будет работать как надо.
//Обратите внимание на то, что для обеспечения собственной реализации в обоих
//классах. CDProduct и BookProduct, переопределяется метод getSummaryLine(). Производные
//классы могут расширять и изменять функциональность родительских
//классов. И в то же время каждый класс наследует свойства родительского класса.
//Реализация метода getSummaryLine() в суперклассе может показаться избыточной,
//поскольку метод переопределяется в обоих дочерних классах. Тем не менее мы
//предоставляем базовый набор функциональных возможностей, который можно будет
//использовать в любом новом дочернем классе. Наличие этого метода в суперклассе
//также гарантирует для клиентского кода, что во всех объектах типа
//ShopProduct будет присутствовать метод getSummaryLine(). Позже вы увидите, как
//можно выполнить это требование в базовом классе, не предоставляя никакой его
//реализации. Каждый дочерний объект класса ShopProduct унаследует все свойства
//своего родителя. В собственных реализациях метода getSummaryLine() для обоих
//классов, CDProduct и BookProduct. обеспечивается доступ к свойству $title.
//С понятием наследования сразу разобраться непросто. Определяя класс, который
//расширяет другой класс, мы гарантируем, что экземпляр его объекта определяется
//характеристиками сначала дочернего, а затем - родительского класса. Чтобы
//понять это. нужно размышлять с точки зрения поиска. При вызове $product2->
//getProducer() интерпретатор РНР не может найти такой метод в классе CDProduct.
//Поиск заканчивается неудачей, и поэтому используется стандартная реализация
//этого метода. заданная в классе ShopProduct. С другой стороны, когда мы вызываем
//$product2->getSummaryLine(). интерпретатор РНР находит реализацию метода
//getSummaryLine() в классе CDProduct и вызывает его.
//То же самое верно и в отношении доступа к свойствам. При обращении к свойству
//$title в методе getSummaryLine() из класса BookProduct интерпретатор РНР не
//находит определение этого свойства в классе BookProduct. Поэтому он использует
//определение данного свойства, заданное в родительском классе ShopProduct.
//Поскольку свойство $title используется в обоих подклассах, оно должно определяться
//в суперклассе.
//Даже поверхностного взгляда на конструктор ShopProduct достаточно, чтобы понять,
//что в базовом классе по-прежнему выполняется обработка тех данных, которыми
//должен оперировать дочерний класс . Так, конструктору класса BookProduct
//должен передаваться аргумент $numPages. значение которого заносится в одноименное
//свойство, а конструктор класса CDProduct должен обрабатывать аргумент и
//свойство $playLength. Чтобы добиться этого, мы определим методы конструктора
//в каждом дочернем классе.

//Конструкторы и наследование
//При определении конструктора в дочернем классе вы берете на себя ответственность
//за передачу требуемых аргументов родительскому классу. Если же вы этого не
//сделаете, то у вас получится частично сконструированный объект.
//Чтобы вызвать нужный метод родительского класса, вам понадобится обратиться
//к самому этому классу через дескриптор. Для этой цели в РНР предусмотрено
//ключевое слово parent.
//Чтобы обратиться к методу в контексте класса, а не объекта, следует использовать
//символы "::". а не "->". Поэтому конструкция parent::_construct() означает
//следующее: "Вызвать мeтoд _construct() родительского класса". Давайте изменим
//наш пример так, чтобы каждый класс оперировал только теми данными, которые
//имеют к нему отношение.

//Каждый дочерний класс вызывает конструктор своего родительского класса,
//прежде чем определять собственные свойства. Базовый класс теперь "знает" только
//о собственных данных. Дочерние классы - это обычно "специализации" родительских
//классов. Как правило, следует избегать того. чтобы давать родительским классам
//какие-либо особые "знания" о дочерних классах.

//Вызов переопределенного метода
//Ключевое слово parent можно использовать в любом методе. который переопределяет
//свой эквивалент в родительском классе. Когда мы переопределяем метод. то,
//возможно, хотим не удалить функции "родителя", а. скорее, расширить их. Достичь
//этого можно, вызвав метод родительского класса в контексте текущего объекта.
//Если вы снова посмотрите на реализации метода getSummaryLine(), то увидите, что
//значительная часть кода в них дублируется. И лучше этим воспользоваться, чем повторять
//функциональность, уже разработанную в классе ShopProduct.
//Мы определили основные функции для метода getSummaryLine() в базовом классе
//ShopProduct. Вместо того чтобы повторять их в подклассах CDProduct и BookProduct,
//мы просто вызовем родительский метод, прежде чем добавлять дополнительные
//данные к итоговой строке.
//Теперь. когда мы познакомились с основами наследования, можно, наконец, рассмотреть
//вопрос видимости свойств и методов в свете полной картины происходящего.

//Public, Private и Protected: управление доступомк классам
//До сих пор мы явно или неявно объявляли все свойства как public (общедоступные).
//Такой тип доступа задан по умолчанию для всех методов. а также свойств,
//объявленных с использованием устаревшего ключевого слова var.
//Элементы класса можно объявить как public(общедоступные), private(закрытые)
//или protected(защищенные).
//• К общедоступным свойствам и методам можно получать доступ из любого
//  контекста.
//• К закрытому свойству и методу можно получить доступ только из того класса,
//  в котором они объявлены. Даже подклассы данного класса не имеют доступа
//  к таким свойствам и методам.
//• К защищенным свойствам и методам можно получить доступ либо из содержащего
//  их класса, либо из его подкласса. Никакому внешнему коду такой доступ
//  не предоставляется.
//Чем это может быть нам полезно? Ключевые слова, определяющие область видимости,
//позволяют показывать только те аспекты класса, которые требуются клиенту.
//Это позволяет создать ясный и понятный интерфейс для объекта.

//Контроль доступа, позволяющий запрещать клиенту доступ к некоторым свойствам,
//поможет также избежать ошибок в коде. Предположим, мы хотим сделать
//так, чтобы в объектах типа Shop Product поддерживались скидки. Для этого можно
//добавить свойство $discount и метод setDiscount().

//// класс ShopProduct . . .
//public $discount = 0;
//
//function setDiscount($num) {
//    $this->discount=$num;
//}

//Вооруженные механизмом определения скидки, мы можем создать метод get
//Price(). который принимает во внимание установленную скидку.

//// класс ShopProduct . . .
//function getPrice ( ) {
//    return ( $this->price - $this->discount );

//Но тут у нас есть проблема. Мы хотим показать всем только скорректированную
//цену, но клиент может легко обойти метод getPrice() и получить доступ к свойству
//$price.
//print " Цена - { $product1->price } \n";

//В результате будет выведена исходная цена, а не цена со скидкой, которую мы
//хотим представить. Чтобы предотвратить это. можно просто закрыть свойство
//$price. Это позволит запретить клиентам прямой доступ к нему. заставляя использовать
//метод getPrice(). Любая попытка получить доступ к свойству $price из-за
//пределов класса ShopProduct закончится неудачей. В результате для внешнего мира
//это свойство прекратит существование.
//Но определение свойств как private - не всегда удачная стратегия, поскольку
//тогда дочерний класс не сможет получить доступ к закрытым свойствам . А теперь
//представьте. что правила вашего бизнеса таковы: при покупке только книг скидку
//на них делать нельзя. Мы можем переопределить метод getPrice(), чтобы он возвращал
//свойство $price без применения скидки.
//// класс BookProduct . . .
//function getPrice() {
//    return $this->price;

//Поскольку свойство $price объявлено в классе ShopProduct, а не в BookProduct,
//попытка в приведенном выше коде получить к нему доступ закончится неудачей.
//Чтобы решить эту проблему, нужно объявить свойство $price защищенным
//(protected) и тем самым предоставить доступ к нему дочерним классам. Помните.
//что к защищенному свойству или методу нельзя получить доступ из-за пределов иерархии
//того класса, в котором это свойство или метод был объявлен. Доступ к ним
//можно получить только из исходного класса или его дочерних классов.
//Как правило, появление ошибок при доступе к свойствам или методам способствует
//созданию хорошо защищенного кода. Сначала сделайте свойства закрытыми
//или защищенными. а затем ослабляйте ограничения по мере необходимости.
//Многие (если не все) методы в ваших классах будут общедоступными. но. повторяю
//еще раз, если у вас есть сомнения, ограничьте доступ. Метод. предоставляющий локальные
//функции другим методам в классе, не нужен пользователям класса.
//Поэтому сделайте его закрытым или защищенным.