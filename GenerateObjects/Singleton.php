<?php
class Preferences {
    private $props = array();
    private static $instance;

    private function __construct() { }

    public static function getInstance() {
        if(empty(self::$instance)) {
            self::$instance = new Preferences();
        }
        return self::$instance;
    }

    public function setProperty($key, $val) {
        $this->props[$key] = $val;
    }

    public function getProperty($key) {
        return $this->props[$key];
    }
}
//------------------------------------------ RUN
$pref = Preferences::getInstance();
$pref->setProperty("name", "Petrov");

unset($pref);

$pref2 = Preferences::getInstance();
//Убедимся, что ранее установленное значение сохранено
print $pref2->getProperty("name") . "\n";
//------------------------------------------ RESULT
//Petrov

//------------------------------------------ DOCUMENTATION
//глобальная переменная - это один из самых больших источников проблем
//для программиста, использующего ООП. Причины этого к настоящему моменту
//уже должны быть вам понятны. глобальные переменные привязывают классы к
//их контексту. подрывая основы инкапсуляции.Если в классе используется
//глобальная переменная. то его невозможно извлечь из одного приложения и
//применить в другом, не убедившись сначала, что в новом приложении определяются
//такие же глобальные переменные. Незащищенная природа глобальных переменных
//может стать причиной серьезных проблем, хотя их и удобно использовать. Как скоро
//вы начнете зависеть от глобальных переменных, это только вопрос времени, например.
//когда в одной из библиотек будет объявлена глобальная переменная. которая
//окажется в конфликте с другой глобальной переменной, объявленной где-то в другом
//месте. Мы уже видели. что РНР уязвим к конфликтам между именами классов, но это
//гораздо хуже. РНР не предупредит вас. когда произойдет конфликт глобальных переменных.
//Вы узнаете об этом только тогда. когда сценарий начнет вести себя не так. как обычно.
//А еще хуже, если вы вообще не заметите никаких проблем при разработке кода. Но.
//используя глобальные переменные, вы потенциально оставляете пользователей наедине
//с угрозой новых конфликтов, когда они попытаются использовать вашу библиотеку наряду с
//другими.

//Итак, насколько хорош подход с использованием шаблона Singleton по сравнению с
//глобальными переменными? Начнем с плохого. И шаблоном Singleton, и глобальными переменными
//часто злоупотребляют. Поскольку доступ к объектам Singleton можно получить из любого места
//системы, они могут способствовать созданию зависимостей, которые затрудняют отладку приложения.
//А в случае изменения шаблона Singleton это повлияет на классы , которые его используют.
//Зависимости не представляют проблемы сами по себе. В конце концов, мы создаем зависимость
//каждый раз, когда объявляем, что методу требуется передать аргумент определенного типа. Проблема
//в том, что глобальная природа шаблона Singleton позволяет программисту обойти каналы коммуникации,
//определенные интерфейсами класса. Когда используется Singleton, зависимость скрыта внутри метода и
//не объявляется в его сигнатуре. Это затрудняет отслеживание связей внутри системы. Поэтому классы
//Singleton должны использоваться редко и очень осторожно. Тем не менее я считаю, что умеренное
//использование шаблона Singleton может улучшить проект системы, избавив ее от излишнего загромождения
//при передаче ненужных объектов в системе.

//Шаблоны Singleton - это шаг вперед по сравнению с использованием глобальных переменных в
//объектно-ориентированном контексте. Вы не сможете затереть объекты Singleton неправильными данными.
//Такой вид защиты особенно важен в версиях РНР, в которых нет поддержки пространства имен. Любой конфликт
//имен будет обнаружен на стадии компиляции, что приведет к завершению выполнения программы.