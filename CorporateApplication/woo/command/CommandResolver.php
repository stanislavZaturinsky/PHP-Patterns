<?php
namespace woo\command;

class CommandResolver
{
    private static $base_cmd = null;
    private static $default_cmd = null;

    function __construct()
    {
        if (is_null(self::$base_cmd)) {
            self::$base_cmd = new \ReflectionClass('\woo\command\Command');
            self::$default_cmd = new DefaultCommand();
        }
    }

    function getCommand(\woo\controller\Request $request)
    {
        $cmd = $request->getProperty('cmd');
        $sep = DIRECTORY_SEPARATOR;
        if (!$cmd) {
            return self::$default_cmd;
        }

        $cmd = str_replace(['.', $sep], '', $cmd);
        $filepath = "woo{$sep}command{$sep}{$cmd}.php";
        $classname = "woo\\command\\$cmd";

        if (file_exists($filepath)) {
            require_once($filepath);
            if (class_exists($classname)) {

                $cmd_class = new ReflectionClass($classname);
                if ($cmd_class->isSubClassOf(self::$base_cmd)) {
                    return $cmd_class->newInstance();
                } else {
                    $request->addFeedback("Объект Command команды '$cmd' не найден");
                }
            }
        }
        $request->addFeedback("Команда '$cmd' не найдена");
        return clone self::$default_cmd;
    }
}
//-------------------------------- DOCUMENTATION
//Контроллеру нужен способ. позволяющий решить, как интерпретировать НТТР запрос,
//чтобы в результате можно было вызывать нужный код для обработки этого
//запроса. Конечно. можно легко включить эту логику в сам класс Controller. но я
//предпочитаю использовать для этой цели специальный класс. В случае необходимости
//это позволит легко сделать рефакторинr для полиморфизма.
//В шаблоне Front Controller логика приложения часто вызывается путем запуска
//объекта Command. Этот объект обычно выбирается в соответствии со значением
//параметра запроса или структурой самого URL (например. вы можете использовать
//настройки сервера Apache, чтобы заменить конкретные URL ключами, которые используются
//для вызова соответствующего объекта типа Command). В приведенных примерах я буду
//использовать простой параметр: cmd.
//Существует несколько способов использования заданного параметра для выбора
//команды. Вы можете сопоставить параметр с конкретным методом через файл конфигурации
//или структуру данных (логическая стратегия}. Или можете отобразить
//его непосредственно на файл класса. расположенный в файловой системе ( физическая
//стратегия).
//Логическая стратегия более гибкая. но в то же время и более трудоемкая. если
//говорить о ее установке и поддержке.
//Приведен небольшой вариант этого примера, в котором
//используется рефлексия с целью повышения безопасности.

//В этом простом классе выполняется поиск параметра запроса cmd. Предположим,
//что он найден и соответствует реальному файлу класса в каталоге команд и что этот
//файл класса содержит нужный тип класса. Тогда метод getCommand() создает и возвращает
//экземпляр соответствующего класса.
//Если какие-либо из этих условий не удовлетворяются, то метод getCommand()
//возвращает стандартный объект Command. Возможно, вас интересует, почему в этом коде
//принимается на веру то, что конструктору класса Command, который он находит, не требуется
//передавать никаких параметров.