<?php
include '../Inheritance/ShopProductWriter.php';
include '../Inheritance/ShopProductFinish.php';
class StaticExample {
    static public $aNum = 0;

    static public function sayHello() {
        self::$aNum++;
        print 'Привет! (' . self::$aNum . ')<br>';
    }

    public static function getInstance($id, PDO $pdo) {
        $stmt = $pdo->prepare("select * from products where id=?");
        $result = $stmt->execute([$id]);

        $row = $stmt->fetch();

        if(empty($row)) { return null;}

        if($row['type'] === 'book') {
            $product = new BookProduct(
                $row['title'],
                $row['firstname'],
                $row['mainname'],
                $row['price'],
                $row['numpages']
            );
        } elseif($row['type'] === 'cd') {
            $product = new CDProduct(
                $row['title'],
                $row['firstname'],
                $row['mainname'],
                $row['price'],
                $row['playlength']
            );
        } else {
            $product = new CDProduct(
                $row['title'],
                $row['firstname'],
                $row['mainname'],
                $row['price']
            );
        }
        $product->setId($row['id']);
        $product->setDiscount($row['discount']);
        return $product;
    }
}
//------------------------------------------ RUN
$dsn = "sqlite://sqlite/product.db";
$pdo = new PDO($dsn, null, null);
$pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
$obj = StaticExample::getInstance(1,$pdo);
//------------------------------------------ DOCUMENTATION
//Статические методы и свойства
//Во всех примерах предыдущей главы м ы работали с объектами. Я охарактеризовал
//классы как шаблоны, с помощью которых создаются объекты, а объекты - как
//активные компоненты, методы которых мы вызываем и к свойствам которых получаем
//доступ. Отсюда следовал вывод. что в объектно-ориентированном программировании
//реальная работа выполняется с помощью экземпляров классов. А классы
//в конечном счете - это просто шаблоны для создания объектов.
//Но на самом деле не все так просто. Мы можем получать доступ и к методам, и
//к свойствам в контексте класса, а не объекта. Такие методы и свойства являются
//"статическими" и должны быть объявлены с помощью ключевого слова static.

//Статические методы - это функции, используемые в контексте класса. Они
//сами не могут получать доступ ни к каким обычным свойствам класса, потому что
//такие свойства принадлежат объектам . Однако из статических методов можно обращаться
//к статическим свойствам. И если вы измените статическое свойство, то
//все экземпляры этого класса смогут получать доступ к новому значению.
//Поскольку доступ к статическому элементу осуществляется через класс, а не экземпляр
//объекта, вам не нужна переменная, которая ссылается на объект. Вместо
//этого используется имя класса, после которого указывается два двоеточия "::".

//print StaticExample::$aNum;
//StaticExample::sayHello();

//Мы использовали конструкцию "::" в сочетании с ключевым словом parent, чтобы получить доступ
//к переопределенному методу родительского класса. Однако теперь мы будем обращаться
//к классу, а не к данным. содержащимся в объекте. В коде класса можно использовать
//ключевое слово parent, чтобы получить доступ к суперклассу, не используя
//имя класса. Чтобы получить доступ к статическому методу или свойству из того
//же самого класса (а не из дочернего класса), мы будем использовать ключевое слово
//self. Ключевое слово self используется для обращения к текущему классу, точно
//так же, как псевдопеременная $this - к текущему объекту. Поэтому из-за пределов
//класса StaticExample мы должны обращаться к свойству $aNum с помощью имени
//его класса
//StaticExample::$aNum;
//А внутри класса StaticExample можно использовать ключевое слово self.

//По определению к статическим методам и свойствам происходит обращение
//в контексте класса, а не объекта. По этой причине статические свойства и методы
//часто называют переменными и свойствами класса. Как следствие привязки к
//классу внутри статического метода нельзя использовать псевдопеременную $this
//для доступа к статическим элементам класса.
//А зачем вообще нужны статические методы или свойства? Статические элементы
//имеют ряд полезных характеристик. Во-первых. они доступны из любой точки
//сценария (при условии, что у вас есть доступ к классу). Это означает, что вы можете
//вызывать функции, не передавая экземпляр класса от одного объекта другому или,
//что еще хуже, сохраняя экземпляр объекта в глобальной переменной. Во-вторых,
//статическое свойство доступно каждому экземпляру объекта этого класса. Поэтому
//можно определить значения, которые должны быть доступны всем объектам данного
//типа. И наконец, в-третьих, сам факт, что не нужно иметь экземпляр класса
//для доступа к его статическому свойству или методу, позволит избежать создания
//экземпляров объектов исключительно ради вызова простой функции.
//Чтобы продемонстрировать это, давайте создадим статический метод для класса
//ShopProduct. который будет автоматически создавать экземпляры объектов
//ShopProduct на основе информации, хранящейся в базе данных. С помощью SQLite
//определим таблицу products следующим образом.

//Теперь создадим метод getInstance(), которому передаются идентификатор
//строки и объект типа PDO. Они будут использоваться для извлечения строки
//из таблицы базы данных, на основании которой затем формируется объект типа
//ShopProduct, возвращаемый в вызывающую программу. Мы можем добавить эти
//методы к классу ShopProduct. который был создан в предыдущей главе. Как вы, наверное,
//знаете, РОО расшифровывается как РНР Data ОЬjесt (объекты данных РНР).
//Класс PDO обеспечивает универсальный интерфейс для различных приложений баз
//данных.

//Как видите, метод getInstance() возвращает объект типа ShopProduct, причем
//он достаточно "умен" для того, чтобы на основании значения поля t yp e создать
//объект с нужными характеристиками . Я специально опустил код обработки ошибок,
//чтобы пример был по возможности лаконичным. Например, в реально работающей
//версии этого кода нам нельзя быть слишком доверчивыми и предполагать,
//что переданный РDО-объект был корректно проинициализирован и подключен
//к требуемой базе данных. На самом деле нам, вероятно, следует заключить РDО объект
//в класс-оболочку, который гарантирует такое поведение.
//Метод getInstance() более полезен в контексте класса, чем в контексте объекта.
//Он позволяет легко преобразовать данные, находящиеся в базе данных, в объект, причем
//для этого нам не нужно иметь отдельный экземпляр объекта типа ShopProduct.
//В этом методе не используются никакие методы или свойства, требующие отдельного
//экземпляра объекта, поэтому нет никакой причины, чтобы не объявить его статическим.
//Тогда, имея корректный РDО-объект. мы можем вызвать данный метод из
//любого места приложения.

//Подобные методы работают, как "фабрики", поскольку они берут "сырые" материалы
//(например, данные, полученные из строки базы данных или файла конфиrурации)
//и используют их для создания объектов. Термин фабрика относится к коду,
//предназначенному для создания экземпляров объектов. С примерами подобных
//"фабрик" мы еще встретимся в последующих главах.
//Разумеется на основе рассмотренного выше примера мы в какой-то степени показали
//далеко не все проблемы . И хотя я сделал метод ShopProduct::getInstance()
//доступным из любой части программы без необходимости создавать экземпляр объекта
//ShopProduct, я также потребовал, чтобы объект PDO был передан из клиентского
//кода. Откуда мы должны его взять? В объектно-ориентированном программировании
//существует еще ряд подобных широко распространенных проблем, например
//где взять набор ключевых объектов программы и их значений.
