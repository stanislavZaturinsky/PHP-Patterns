<?php
class ShopProductWriter {
    public $products = [];

    public function addProduct(ShopProduct $shopProduct) {
        $this->products[] = $shopProduct;
    }

    public function write() {
        $str = '';
        foreach($this->products as $shopProduct) {
            $str .=  "{$shopProduct->title}: ";
            $str .=    $shopProduct->getProducer();
            $str .= "({$shopProduct->getPrice()})<br>";
        }
        print $str;
    }
}
//------------------------------------------ DOCUMENTATION
//Методы как средство доступа к свойствам
//Даже если в клиентской программе нужно будет работать со значениями, хранящимися
//в экземпляре вашего класса. как правило, стоит запретить прямой доступ к
//свойствам этого объекта. Вместо этого создайте методы. которые возвращают или
//устанавливают нужные значения. Такие методы называют методами доступа
//(accessors) или получателями (getter) и установщиками (setter).
//Вы уже видели одно преимущество, которое дают методы доступа: их можно использовать
//для фильтрации значений свойств в зависимости от обстоятельств, как
//было проиллюстрировано выше с помощью метода getPrice().
//Метод-установщик может также использоваться для принудительного определения
//типа свойства. Мы уже видели, что для ограничения типа аргументов метода
//можно использовать уточнения. но у нас нет непосредственного контроля над типами
//свойств. Помните определение класса Shop ProductWriter, с помощью которого
//выводилась информация об объектах типа ShopProduct? Давайте попробуем пойти
//дальше и сделать так. чтобы класс S ho p ProductWriter мог выводить информацию о
//любом количестве объектов типа ShopProduct одновременно.

//Теперь класс ShopProductWriter стал намного полезнее. Он может содержать
//много объектов типа ShopProduct и сразу выводить информацию обо всех них. Но
//мы все еще должны полагаться на то, что программисты клиентского кода будут
//строго придерживаться правил работы с классом. Хотя мы предоставили метод
//addProduct(), мы не запретили программистам непосредственно выполнять операции
//над свойством $products. В результате можно не только добавить объект неправильного
//типа к массиву свойств $products, но и затереть весь массив и заменить
//его значением элементарного типа. Чтобы не допустить этого, нужно сделать свойство
//$products закрытым.

//class ShopProductWri ter {
//    private $products = array ();

//Теперь внешний код не сможет повредить массив свойств $products . Весь доступ
//к нему должен осуществляться через метод addProduct(), а уточнения типа класса,
//которые используются в объявлении этого метода, гарантируют, что к массиву
//свойств могут быть добавлены только объекты типа ShopProduct.